# Linux_D02:

----------------------------------------------------------------------------

- [Linux\_D02:](#linux_d02)
    - [1. Инструмент ipcalc:](#1-инструмент-ipcalc)
    - [2. Статическая маршрутизация между двумя машинами:](#2-статическая-маршрутизация-между-двумя-машинами)
    - [3. Утилита iperf3:](#3-утилита-iperf3)
    - [4. Сетевой экран:](#4-сетевой-экран)
    - [5. Статическая маршрутизация сети:](#5-статическая-маршрутизация-сети)
    - [6. Динамическая настройка IP с помощью DHCP:](#6-динамическая-настройка-ip-с-помощью-dhcp)
    - [7. NAT:](#7-nat)
    - [8. Знакомство с SSH Tunnels:](#8-знакомство-с-ssh-tunnels)

----------------------------------------------------------------------------

## 1. Инструмент ipcalc:
- Подняла vm на **Ubuntu 24.04.6 LTS** с *hostname* **ws1**  и выполнила команду `cat /etc/issue`, чтобы проверить версию.

> Вывод файла `/etc/issue`:
>
![alt text](Screen/1.png)
>

- Выполнила команду от имени администратора `sudo` `apt install ipcalc`, чтобы скачать утилиту ipcalc.

**1.1 Сети и маски:**
1) Адрес сети:

- Выполнила команду `ipcalc 192.167.38.54/13`.

> Вывод команды `ipcalc 192.167.38.54/13`:
>
> ![alt text](Screen/2.png)
>

- 192.167.38.54/13:
  - Адрес сети: 192.160.0.0

2) Перевод маски:
 - Выводы поочередно:
 - Префиксная запись: /24
  - Двоичная запись: 11111111.11111111.11111111.00000000
- /15:
  - Обычная запись: 255.254.0.0
  - Двоичная запись: 11111111.11111110.00000000.00000000
- Маска 11111111.11111111.11111111.11110000 содержит 28 единиц, поэтому префиксная запись выглядит как /28.
- Выполнила команду `ipcalc 0.0.0.0/28`.
- 11111111.11111111.11111111.11110000:
  - Префиксная запись: /28
  - Обычная запись: 255.255.255.240

>![ !\[Вывод команды ipcalc 255.255.255.0\](screen%2Fscreen_1_04.png)](Screen/3.png)

3) Минимальный и максимальный хост в сети:
> ![!\[Вывод команды ipcalc 12.167.38.4/8\](screen%2Fscreen_1_07.png)](Screen/4.png)
>

**1.2. localhost:**

*Диапазон адресов 127.0.0.0/8 называется диапазоном адресов внутреннего хоста (Internal host loopback). IPv4-адреса такой формы используются для обращения к самому хосту. Если вы запросите любой из этих адресов на любом сетевом устройстве, вы должны получить ответ.*

**Статья в [Wikipedia](https://en.wikipedia.org/wiki/Localhost)**.

- Выполнила команду `ipcalc 127.0.0.0/8`.

> Вывод команды `ipcalc 127.0.0.0/8`:
>
> ![alt text](Screen/8.2.png)
>

- Диапазон сети 127.0.0.0/8:
  - Минимальный хост: 127.0.0.1
  - Максимальный хост: 127.255.255.254

| Адрес | Диапазон                          | Приложение на localhost  с данным ip                    |
| -------- |-----------------------------------|---------------------------------------------------------|
| 194.34.23.100:    | Адрес не в диапазоне 127.0.0.0/8. | Нельзя обратиться к приложению на localhost с этого IP. |
| 127.0.0.2:     | Адрес из диапазона 127.0.0.0/8.   | Можно обратиться к приложению на localhost с этого IP.  |
| 127.1.0.1:    | Адрес из диапазона 127.0.0.0/8.   | Можно обратиться к приложению на localhost с этого IP.  |
| 128.0.0.1:    | Адрес не в диапазоне 127.0.0.0/8. | Нельзя обратиться к приложению на localhost с этого IP. |

**1.3. Диапазоны и сегменты сетей:**

*Частные внутренние адреса не маршрутизируются в Интернете и на них нельзя отправить трафик из Интернета, они работают только в пределах локальной сети.*

- *К частным "серым" адресам относятся IP-адреса из следующих подсетей:*
  - От 10.0.0.0 до 10.255.255.255 с маской 255.0.0.0 или /8 
    - **10.0.0.0/8**
  - От 172.16.0.0 до 172.31.255.255 с маской 255.240.0.0 или /12 
    - **172.16.0.0/12**
  - 192.168.0.0 до 192.168.255.255 с маской 255.255.0.0 или /16 
    - **192.168.0.0/16**


- Выполнила команду `ipcalc 10.0.0.0/8`, чтобы узнать диапазон сети.

> Вывод команды `ipcalc 10.0.0.0/8`:
>
> ![alt text](Screen/8.3.png)
>

- Диапазон сети 10.0.0.0/8:
  - Минимальный хост: 10.0.0.1
  - Максимальный хост: 10.255.255.254

- Выполнила команду `ipcalc 172.16.0.0/12`, чтобы узнать диапазон сети.

> Вывод команды `ipcalc 172.16.0.0/12`:
>
> ![alt text](Screen/8.4.png)
>

- Диапазон сети 172.16.0.0/12:
  - Минимальный хост: 172.16.0.1
  - Максимальный хост: 172.31.255.254

- Выполнила команду `ipcalc 192.168.0.0/16`, чтобы узнать диапазон сети.

> Вывод команды `ipcalc 192.168.0.0/16`:
>
> ![alt text](Screen/8.5.png)
>

- Диапазон сети 192.168.0.0/16:
  - Минимальный хост: 192.168.0.1
  - Максимальный хост: 192.168.255.254

Адреса **10.0.0.45**, **192.168.4.2**, **172.20.250.4**, **172.16.255.255** и **10.10.10.10** входят в диапазоны проверенных сетей, следовательно, они являются частными адресами.

Адреса **134.43.0.2**, **172.0.2.1**, **192.172.0.1**, **172.68.0.2** и **192.169.168.1** находятся вне этих диапазонов, значит их можно использовать в качестве публичных адресов.

- Выполнила команду `ipcalc 10.10.0.0/18`, чтобы узнать диапазон сети.

> Вывод команды `ipcalc 10.10.0.0/18`:
>
>![alt text](Screen/8.6.png)
>
- Диапазон сети 10.10.0.0/18:
  - Минимальный хост: 10.10.0.1
  - Максимальный хост: 10.10.63.254

*Адрес шлюза сети должен входить в диапазон HostMin - HostMax.*
- Возможные адреса шлюза у сети **10.10.0.0/18**:
  - **10.10.0.2**
  - **10.10.10.10**
  - **10.10.1.255**

Адреса **10.0.0.1** и **10.10.100.1** не входят в указанный диапазон, и не могут являться шлюзом этой сети.

----------------------------------------------------------------------------

## 2. Статическая маршрутизация между двумя машинами:

**2.1. Сетевые интерфейсы:**

- Подняла вторую vm с *hostname* **ws2**.
- Выполнила команду `ip a`, чтобы посмотреть существующие сетевые интерфейсы на **ws1** и **ws2**.

> ![!\[Вывод команды ip a ws1\](screen%2Fscreen_2_02.png)](Screen/5.png)
> ![alt text](Screen/6.png)

*Чтобы добавить ещё один интерфейс, соответсвующий внутренней сети, нужно изменить настройки в **Virtual Box**.*

- Выполнила команду `ip a`, чтобы убедиться, что интерфейс добавился.
>
> ![!\[Добавление нового интерфейса в VB ws2\](screen%2Fscreen_2_07.png)](Screen/7.png)
>

**Настраиваем сетевые интерфейсы, с заданными адресами и масками:**

- Изменила файл конфигурации *netplan* на **ws1** и **ws2**.

> Измененный файл конфигурации `/etc/netplan/00-installer-config.yaml` (ws1) (ws2):
>
> ![alt text](Screen/8.png)
>

```yaml
network: # Основной раздел, который описывает конфигурацию сети
  ethernets: # Раздел, в котором перечислены сетевые интерфейсы
    enp0s3: # Интерфейс с типом подключения NAT (используется для доступа в интернет)
      dhcp4: true # Включение DHCP для данного интерфейса (динамическая настройка IP).
    enp0s8: # Интерфейс с типом подключения внутренняя сеть (используется для локальной сети)
      dhcp4: false # Отключение DHCP для данного интерфейса (статическая настройка IP).
      addresses: [192.168.100.10/16] / [172.24.116.8/12] # Статический IP-адрес для интерфейса enp0s8 с маской сети /16 (255.255.0.0) / /12 (255.240.0.0).
  version: 2 # Версия схемы Netplan
```

- Выполнила команду от имени администратора `sudo` `netplan apply`, чтобы применить настройки на двух машинах.

**2.1. Добавление статического маршрута вручную:**
- Выполнила команду от имени администратора `sudo` `ip route add 172.24.116.8 dev enp0s3` на ws1.
- Выполнила команду от имени администратора `sudo` `ip route add 192.168.100.10 dev enp0s3` на ws2.

> Добавляем статический маршрут от ws1 до ws2 и обратно + взаимный пинг:
>
> ![alt text](Screen/10.png)
>

**2.2. Добавление статического маршрута с сохранением:**

- Перезапустила обе машины командой от имени администратора `sudo` `reboot`.
- Изменила файлы конфигурации *netplan*.

> Измененный файл конфигурации `/etc/netplan/00-installer-config.yaml` (ws1) и (ws2) + взаимный пинг:
>
> ![alt text](Screen/11.png)
>

```yaml
network: # Основной раздел, который описывает конфигурацию сети
  ethernets: # Раздел, в котором перечислены сетевые интерфейсы
    enp0s3: # Интерфейс с типом подключения NAT (используется для доступа в интернет)
      dhcp4: true # Включение DHCP для данного интерфейса (динамическая настройка IP).
    enp0s8: # Интерфейс с типом подключения внутренняя сеть (используется для локальной сети)
      dhcp4: false # Отключение DHCP для данного интерфейса (статическая настройка IP).
      addresses: [192.168.100.10/16] / [172.24.116.8/12] # Статический IP-адрес для интерфейса enp0s8 с маской сети /16 (255.255.0.0).
      routes: # Раздел для статических маршрутов
        - to: 172.24.116.8 / 192.168.100.10  # IP-адрес назначения для маршрута
          via: 192.168.100.10 / 172.24.116.8   # IP-адрес шлюза для маршрута (в данном случае это тот же IP, что и адрес интерфейса)
  version: 2 # Версия схемы Netplan
```

----------------------------------------------------------------------------

## 3. Утилита iperf3:
<details><summary>Перевод единиц измерения:</summary>

- **8 Mbps в MB/s**:
  - 1 Mbps = 0.125 MB/s
  - Следовательно, 8 Mbps = 8 * 0.125 = **1 MB/s**.


- **100 MB/s в Kbps**:
  - 1 MB/s = 8 Mbps
  - 1 Mbps = 1000 Kbps
  - Следовательно, 100 MB/s = 100 * 8 * 1000 = **800,000 Kbps**.


- **1 Gbps в Mbps**:
  - 1 Gbps = **1000 Mbps**.
</details>

- Выполнила команду `iperf3 -s` на ws2, чтобы настроить её как сервер, и команду `iperf3 -c 192.168.100.10` на ws1, чтобы настроить её как клиент и измерить скорость соединения между машинами.

>
>![alt text](Screen/12.png)
>
> *Средняя скорость соединения между машинами: **698 - 699 Mbits/sec**.*
>

----------------------------------------------------------------------------

## 4. Сетевой экран:
- Создала файл `/etc/firewall.sh`, имитирующий фаервол на ws1 и ws2 
> Настроенный, в соответствии с заданием, файл `/etc/firewall.sh` (ws1) и (ws2):
> ![alt text](Screen/13.png)
>

```bash
#!/bin/sh

# удаление всех правил в таблице «filter» (по умолчанию).
iptables -F  # очистка всех правил в таблице "filter".
iptables -X  # удаление всех нестандартных цепочек в таблице "filter".

# разрешение доступа для порта 22 (SSH) и порта 80 (HTTP).
iptables -t filter -A INPUT -p tcp --dport 22 -j ACCEPT  # разрешение входящих подключений на порт 22 (SSH).
iptables -t filter -A INPUT -p tcp --dport 80 -j ACCEPT  # разрешение входящих подключений на порт 80 (HTTP).

# запрет echo reply (машина не должна «пинговаться»).
iptables -A OUTPUT -p icmp --icmp-type echo-reply -j DROP  # запрещает отправку ICMP echo-reply пакетов.

# разрешение echo reply (машина должна «пинговаться»).
iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT  # разрешение отправки ICMP echo-reply пакетов, что отменяет предыдущее правило.

```

```bash
#!/bin/sh

# разрешение echo reply (машина должна «пинговаться»).
iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT  # разрешение отправки ICMP echo-reply пакетов.

# запрет echo reply (машина не должна «пинговаться»).
iptables -A OUTPUT -p icmp --icmp-type echo-reply -j DROP  # запрещает отправку ICMP echo-reply пакетов, что отменяет предыдущее правило.
```

- Разрешила доступ и запустил файлы на обеих машинах командами от имени администратора `sudo` `chmod +x /etc/firewall.sh` и `sudo` `/etc/firewall.sh`.

> Применение команд `sudo` `chmod +x /etc/firewall.sh` и `/etc/firewall.sh` 
>
> ![!\[alt text\](Screen/14.png)](Screen/15.png)
>

*Разница между примененными стратегиями состоит в порядке применения правил **ACCEPT** / **DROP** на соответствующих машинах, и, что важнее, в особенности работы **iptables**: к пакетам, удовлетворяющим нескольким заданным стратегиям, применяется правило с наименьшим номером в списке. Это приводит к тому, что **ws1** не отвечает на пинг, тогда как **ws2** возвращает ответ.*
- *(Правила выполнябтся сверху-вниз, следовательно, если правило запрета находиться выше оно срабатывает, а правило разрешения находящееся ниже - нет.)*

- Выполнила команду от имени администратора `sudo` `iptables -L --line-number`.
>
> ![alt text](Screen/17.png)
>
*Команда `sudo` `iptables -L --line-number` используется для отображения текущих правил iptables.*
- Разбор команды:
  - Флаг `-L`: сокращение от `--list`, используется для отображения текущих правил в выбранной таблице (по умолчанию, таблица **filter**).
  - Флаг `--line-number`: добавляет номера строк к списку правил. Это позволяет легко ссылаться на конкретное правило при его удалении или изменении.
  
> - Пропинговала **ws2** с **ws1**, командой `ping -c 2 172.24.116.8`.
> - Пропинговала **ws1** с **ws2**, командой `ping -c 3 192.168.100.10`.
> - Выполнила команду `nmap 192.168.100.10` на **ws2**, что бы убедиться, что машина **ws1** запущена.
> - В выводе nmap 192.168.100.10 сказано: Host is up
> ![alt text](Screen/18.png)
> 

*Чтобы сохранить дампы образов виртуальных машин, нужно зайти в **Virtual Box**.*

----------------------------------------------------------------------------

## 5. Статическая маршрутизация сети:
**Соединение статической маршрутизацией сеть из 5 машин:**

- Подняла пять виртуальных машин (3 рабочие станции (**ws11**, **ws21**, **ws22**) и 2 роутера (**r1**, **r2**)), используя те же образы (ISO) Ubuntu 24.04.6 LTS.

> Т/З по маршрутизации:
>
> ![!\[Т/З по маршрутизации\](screen%2Fscreen_5_01.png)](Screen/screen_5_01.png)
>
> *Как показано на схеме, виртуальные машины **ws11**, **ws21**, **ws22** должны иметь по одному интерфейсу для внутренней сети, а **r1** и **r2** — по два интерфейса.*
>

- Добавила дополнительные интерфейсы для виртуальных машин в настройках **Virtual Box**, по аналогии с [заданием 2](#2-статическая-маршрутизация-между-двумя-машинами).


**5.1. Настройка адресов машин:**
>- Изменила файлы конфигурации *netplan* 
>
> ![alt text](Screen/19.1.jpg)
> ![alt text](Screen/19.2.jpg)
> ![alt text](Screen/19.3.jpg)
>

```yaml
network: # Основной раздел, который описывает конфигурацию сети
  ethernets: # Раздел, в котором перечислены сетевые интерфейсы
    enp0s3: # Интерфейс с типом подключения NAT (используется для доступа в интернет)
      dhcp4: true # Включение DHCP для данного интерфейса (динамическая настройка IP).
    enp0s8: # Интерфейс с типом подключения внутренняя сеть (используется для локальной сети)
      dhcp4: false # Отключение DHCP для данного интерфейса (статическая настройка IP).
      addresses: # Статический IP-адрес для интерфейса enp0s8.
    enp0s9: # Интерфейс с типом подключения внутренняя сеть (используется для локальной сети)
      dhcp4: false # Отключение DHCP для данного интерфейса (статическая настройка IP).
      addresses:  # Статический IP-адрес для интерфейса enp0s9.
  version: 2 # Версия схемы Netplan
```

- Командой `ip -4 a` проверила, что адреса машин заданы верно.

*Флаг `-4`: выводит информацию только о сетевых интерфейсах с IPv4 адресами.*

> 
> ![alt text](Screen/24.png)
> ![alt text](Screen/25.png)
>

> - Пропинговала **ws22** с **ws21** и **r1** с **ws11**>
> ![alt text](Screen/26.png)
> ![alt text](Screen/26.2.png)
>

**5.2. Включение переадресации IP-адресов:**
- Выполнила команду от имени администратора `sudo` `sysctl -w net.ipv4.ip_forward=1` на роутерах **r1**, **r2**, чтобы включить временную переадресацию IP (до перезапуска системы).

> Вывод команды 
> ![alt text](Screen/27.png)
>

- Открыла файлы /etc/sysctl.conf на двух машинах и добавила в них строку `net.ipv4.ip_forward = 1`, что бы IP-переадресация была включена на постоянной основе.

> Измененный файл `/etc/sysctl.conf` (r1):
>
> ![alt text](Screen/28.png)
>

> Измененный файл `/etc/sysctl.conf` (r2):
>
> ![alt text](Screen/28.1.png)
>

**5.3. Установка маршрута по-умолчанию:**
- Изменила файлы конфигурации etc/netplan/00-installer-config.yaml на **ws11**, **ws21**, **ws22**, подтвердила настройки и перезапустила сеть командой от имени администратора `sudo` `netplan apply`

> Измененный файл `etc/netplan/00-installer-config.yaml` (ws11):
>
> ![alt text](Screen/29.png)
>


> Измененный файл `etc/netplan/00-installer-config.yaml` (ws21):
>
> ![alt text](Screen/29.1.png)
>


> Измененный файл `etc/netplan/00-installer-config.yaml` (ws22):
>
> ![alt text](Screen/29.2.png)
>


- Выполнила команду `ip r` на **ws11**, **ws21**, **ws22**, чтобы проверить добавился ли маршрут в таблицу маршрутизации.

> Вывод команды `ip r`
>
> ![alt text](Screen/30.png)
> 

- Выполнила команду `ping 10.100.0.12` на **ws11** и команду от имени администратора `sudo` `tcpdump -tn -i enp0s8` на **r2**.

> Вывод команд
> ![alt text](Screen/33.png)
> 
> *Сообщение, которое мы видим в выводе команды **tcpdump** на роутере **r2**, означает, что ICMP запросы (пинг) от машины **ws11** доходят до **r2**.*
> 
> *`10.10.0.2 > 10.100.0.12: ICMP echo request`: Это строка показывает, что пакет ICMP (пинг) отправляется от IP-адреса 10.10.0.2 (ws11) к IP-адресу 10.100.0.12 (r2).*
> 
> *`id 9, seq 4, length 64`: Эти параметры указывают на идентификатор ICMP запроса, номер последовательности и длину пакета соответственно.*
>

**5.4. Добавление статических маршрутов:**

- Изменила файл конфигурации *netplan* на роутере **r1** и **r2**..

> Измененные файлы конфигурации `/etc/netplan/00-installer-config.yaml`:
>
> ![alt text](Screen/37.png)

- Выполнила команду `ip r` на **r1** и **r2**.

> Вывод команды `ip r`:
>
> ![alt text](Screen/38.png)
> 
> Сетевой статический маршрут к сети `10.20.0.0/26` установился по-заданному шлюзу `10.100.0.12`
> Сетевой статический маршрут к сети `10.10.0.0/18` установился по-заданному шлюзу `10.100.0.11`


- Выполнила команду `ip r list 10.10.0.0/18` и `ip r list 0.0.0.0/0` на **ws11**.

> Вывод команд `ip r list 10.10.0.0/18` и `ip r list 0.0.0.0/0` (ws11):
>
> ![alt text](Screen/39.png)
> 
> Для адреса 10.10.0.0/18 маршрут, отличается от 0.0.0.0/0, потому что адресация, попадающая в диапазон 10.10.0.0/18 должна быть отправлена через интерфейс enp0s8, по заданными настройкам netplan.
> 
> Весь остальной трафик направляется через шлюз 10.10.0.1 по маршруту по умолчанию.
>

**5.5. Построение списка маршрутизаторов:**
- Установила утилиту **traceroute** командой от имени администратора `sudo` `apt install traceroute` на все машины.
- Выполнила команду от имени администратора `sudo` `tcpdump -tnv -i eth0` на **r1**.

> Вывод команды `sudo tcpdump -tnv -i eth0` (r1):
>
> ![alt text](Screen/40.png)
>

<details><summary>Флаги команды</summary>

-
  - Флаг `-t`: убирает временные метки (timestamps) из вывода.
  - Флаг `-n`: отключает преобразование IP-адресов в доменные имена.
  - Флаг `-v`: включает "verbose" режим, предоставляя более подробную информацию о каждом пакете.
  - Флаг `-i`: указывает, на каком сетевом интерфейсе захватывать трафик. Вместо <interface> нужно подставить имя интерфейса, например, `enp0s8`.
</details>

- Выполнила команду `traceroute 10.20.0.10` на **ws11**.

> Вывод команды `traceroute 10.20.0.10` (ws11):
>
> ![alt text](Screen/42.png)
>

- Принцип работы **traceroute**:

*Утилита traceroute отправляет пакеты с постепенно увеличивающимся значением поля TTL (Time-To-Live) в заголовке IP. TTL определяет количество "хопов" (то есть маршрутизаторов), через которые пакет может пройти, прежде чем будет отброшен.*

*Первый пакет отправляется с TTL = 1, второй с TTL = 2 и так далее. Пакет с TTL = 1 доходит только до первого маршрутизатора на пути, где его TTL уменьшается до 0, и маршрутизатор отбрасывает пакет.*

*Когда маршрутизатор отбрасывает пакет из-за истекшего TTL, он отправляет обратно ICMP сообщение "Time Exceeded" к источнику (машине, которая запустила traceroute).*

*Утилита traceroute отправляет UDP-пакеты с возрастающим значением TTL к целевому адресу, но эти пакеты направляются на порты, которые, как правило, не используются на целевом хосте. В большинстве случаев это порты с номерами, начиная от 33434 и выше.*

*Если на целевом хосте нет процесса, который "слушает" на этом порту, хост отвечает сообщением ICMP "Destination Unreachable" с кодом "Port Unreachable". Это означает, что пакет достиг цели, но целевой порт недоступен для приема данных.*

> Вывод команды `sudo tcpdump -tnv -i enp0s8` на r1, после запуска **traceroute** на ws11:
>
> ![alt text](Screen/43.png)
>

*Traceroute продолжает отправлять пакеты с возрастающим TTL, пока не достигнет конечного узла. Когда пакет достигает целевого хоста, traceroute получает от него либо ICMP "Echo Reply", если использовался ICMP, либо сообщение о достижении цели, если использовался UDP.*

*Утилита traceroute использует эти сообщения, чтобы узнать, через какие маршрутизаторы проходит путь до конечного адресата.*


**5.6. Использование протокола ICMP при маршрутизации:**
- Выполнила команду `ping -c 1 10.30.0.111` на **ws11**.

> Вывод команды `ping -c 1 10.30.0.111` (ws11):
>
> ![alt text](Screen/45.png)
>

- Выполнила команду от имени администратора `sudo` `tcpdump -tnv -i enp0s8` на **r1**.

> Вывод команды `sudo tcpdump -tnv -i enp0s8` (r1):
>
> ![alt text](Screen/44.png)
>

*Протокол ICMP (Internet Control Message Protocol) — это сетевой протокол, который используется для передачи сообщений об ошибках и управляющих сообщений в IP-сетях. Он является частью набора протоколов семейства IP и работает на сетевом уровне модели OSI.*

- Сохранила дампы образов виртуальных машин в настройках **Virtual Box**, по аналогии с [заданием 4].

> Сохранение дампов образов виртуальных машин в VB:
> ![alt text](Screen/46.5.png)
>

----------------------------------------------------------------------------

## 6. Динамическая настройка IP с помощью DHCP:
- Проверила ip адрес интерфейса у машины **ws22** командой `ip addr`.

> ip адрес интерфейса `enp0s8` (ws22):
>
> ![!\[ip адрес интерфейса enp0s8 ws22\](screen%2Fscreen_6_01.png)](Screen/47.png)
>
> Статический ip 10.20.0.20/26, который мы указали в файле конфигураций **netplan**.
>

**Настройка dhcp сервера**:
- На роутере **r2** установила утилиту `isc-dhcp-server`, командой от имени администратора `sudo` `apt install isc-dhcp-server`.
- Открыла файл `/etc/default/isc-dhcp-server` на роутере **r2**.

*Файл `/etc/default/isc-dhcp-server` используется для настройки параметров запуска службы DHCP. В этом файле можно задать сетевые интерфейсы, на которых будет работать DHCP-сервер.*


- Т.к. мы будем выдавать динамический ip в сети **10.20.0.0**, укажем интерфейс на котором будет работать **DHCP-сервер** - `enp0s9`, потому что он находится в данной сети с ip **10.20.0.1/26**.

> Вывод команды `ip addr` (r2):
>
> ![alt text](Screen/48.png)
>

> Отредактированный файл `/etc/default/isc-dhcp-server` (r2):
>
> ![alt text](Screen/48.1.png)
>

```bash
INTERFACESv4="enp0s9" # DHCP-сервер будет обслуживать запросы DHCPv4 только на интерфейсе enp0s9.
INTERFACESv6="" # для DHCPv6 сервер не будет активен
```

- Открыла файл `/etc/dhcp/dhcpd.conf` на роутере **r2**.

*Файл `/etc/dhcp/dhcpd.conf` - используется, как конфигурация для **DHCP-сервера (ISC DHCP)**. В этом файле задаются параметры, по которым сервер **DHCP** будет выдавать IP-адреса и другие сетевые настройки клиентам в локальной сети.*

- Добавила новые параметры.

> Отредактированный файл. Указал адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети. `/etc/dhcp/dhcpd.conf` (r2):
>
> ![alt text](Screen/48.2.png)

>

```bash
subnet 10.100.0.0 netmask 255.255.0.0 {} # блок определяющий подсеть 10.100.0.0/16

subnet 10.20.0.0 netmask 255.255.255.192 # блок описывает другую подсеть 10.20.0.0/26
{
    range 10.20.0.36 10.20.0.50; #  диапазон IP-адресов, которые DHCP-сервер может выдавать клиентам в этой подсети. В данном случае от 10.20.0.36 до 10.20.0.50.
    option routers 10.20.0.1; #  IP-адрес шлюза по умолчанию, который будет использоваться клиентами в этой подсети. Клиенты будут использовать 10.20.0.1 как основной шлюз для выхода в другие сети.
    option domain-name-servers 10.20.0.1; # IP-адрес DNS-сервера, который будут использовать клиенты. В данном случае, DNS-сервер совпадает с адресом шлюза 10.20.0.1.
}
```

- Открыла файл `/etc/resolv.conf` на роутере **r2**.
- Добавила строку `nameserver 8.8.8.8`

> Отредактированный файл `/etc/resolv.conf` (r2):
>
> ![alt text](Screen/48.3.png)
>

* `nameserver 8.8.8.8` - эта строка добавляет дополнительный **DNS-сервер**, к которому система может обратиться для разрешения доменных имен. В данном случае, это **8.8.8.8** — **публичный DNS-сервер**, предоставляемый компанией **[Google](https://google.com)**. 

- Выполнила команду от имени администратора `sudo` `systemctl restart isc-dhcp-server`, чтобы перезапустить систему **DHCP-сервера** на **r2**.
- Выполнила команду от имени администратора `sudo` `systemctl status isc-dhcp-server`, чтобы проверить статус работы системы на **r2**.

> Успешно запущенная система **DHCP-сервера** (r2):
>
> ![alt text](Screen/49.7.png)
>

- Для получения ip адреса для нашей машины **ws22**, с помощью **DHCP-сервера** на роутере **r2**, настроить файл конфигурации netplan.
- Изменила файл `/etc/netplan/00-installer-config.yaml`.
- Включила динамическое получение ip адреса через **dhcp (`true`)**, и закомментировала строки со статическим заданным ip.
- Применила настройки на **ws22**, командой от имени администратора `sudo` `netplan apply`.
- Проверила получение нового ip от нашего **DHCP-сервера**, командой `ip a`.

> Новый ip адрес (ws22):
>
> ![alt text](Screen/49.9.png)
> `10.20.0.36/26` - полученный ip от нашего **DHCP-сервера**, из диапазона (range): `10.20.0.36` - `10.20.0.50`.
>

- Перезапустила машину **ws22**, командой от имени администратора `sudo` `reboot`.
- Выполнила команду `ip a`, чтобы проверить настройки после перезапуска.

> Вывод команды `ip a` (ws22):
>
> ![alt text](Screen/49.11.png)
>

- Пропинговала **ws22** с **ws21**, командой `ping -c 4 10.20.0.36`.

> Успешно пропингованный ip 10.20.0.36:
>
> ![alt text](Screen/49.10.png)
>

- Проверила ip адрес интерфейса у машины **ws11** командой `ip a`.

> ip адрес интерфейса `enp0s8` (ws11):
>
> ![alt text](Screen/49.12.png)
>
> Статический ip 10.10.0.2/18, который мы указали в файле конфигураций **netplan**.
>

- Настроила файл конфигурации `/etc/netplan/00-installer-config.yaml` на **ws11**.

> Отредактированный файл `/etc/netplan/00-installer-config.yaml` (ws11):
>
> ![alt text](Screen/49.13.png)
>
> Указала для интерфейса **enp0s8** MAC-адрес: `10:10:10:10:10:BA`, включила динамическое получение ip адреса через **dhcp (`true`)**, и закомментировала строки со статическим заданным ip.
>

- Открыла интерфейс **Virtual Box**.
- Зашла в настройки сети машины **ws11**, и указала MAC-адрес: `10:10:10:10:10:BA` для интерфейса с внутренней сетью.

> Указание нового MAC-адреса в VB **ws11**:
>
> ![!\[Указание нового MAC-адреса в VB ws11\](screen%2Fscreen_6_16.png)](Screen/49.15.png)
>

- Установила утилиту `isc-dhcp-server` на **r1**.
- Добавила в файл `/etc/resolv.conf` строку - `nameserver 8.8.8.8`, по аналогии с **r2**.

> Отредактированный файл `/etc/resolv.conf` (r1):
>
> ![!\[\](Screen/49.16.png)](Screen/49.16.png)
>

- Указала в `/etc/default/isc-dhcp-server` на **r1**, интерфейс на котором будет работать **DHCP-сервер**.

> Отредактированный файл `/etc/default/isc-dhcp-server` (r1):
>
> ![!\[Отредактированный файл /etc/default/isc-dhcp-server r2\](screen%2Fscreen_6_18.png)](Screen/49.17.png)
>

```bash
INTERFACESv4="enp0s8" # DHCP-сервер будет обслуживать запросы DHCPv4 только на интерфейсе enp0s8.
INTERFACESv6="" # для DHCPv6 сервер не будет активен
```

- Отредактировала файл `/etc/dhcp/dhcpd.conf` на роутере **r1**, по аналогии с **r2**, но сделала выдачу адресов с жесткой привязкой к MAC-адресу (ws11).

> Отредактированный файл `/etc/dhcp/dhcpd.conf` (r1):
>
> ![alt text](Screen/49.19.png)

```bash
subnet 10.100.0.0 netmask 255.255.0.0 {} # блок определяющий подсеть 10.100.0.0/16

subnet 10.10.0.0 netmask 255.255.192.0 # блок описывает другую подсеть 10.10.0.0/18
{
    range 10.10.0.2 10.10.0.50; #  диапазон IP-адресов, которые DHCP-сервер может выдавать клиентам в этой подсети. В данном случае от 10.10.0.2 до 10.10.0.50.
    option routers 10.10.0.1; #  IP-адрес шлюза по умолчанию, который будет использоваться клиентами в этой подсети. Клиенты будут использовать 10.10.0.1 как основной шлюз для выхода в другие сети.
    option domain-name-servers 10.10.0.1; # IP-адрес DNS-сервера, который будут использовать клиенты. В данном случае, DNS-сервер совпадает с адресом шлюза 10.10.0.1.
    
    host ws11 # блок, описывающий параметры для устройства с именем ws11. Этот блок задает статический IP-адрес для устройства на основе его MAC-адреса.
         {
         hardware ethernet 10:10:10:10:10:BA; #  MAC-адрес устройства ws11. Этот адрес используется для идентификации устройства при выдаче IP-адреса.
         fixed-address 10.10.0.45; # статический IP-адрес 10.10.0.45, который будет всегда назначаться устройству ws11, когда оно подключается к этой подсети через DHCP-сервер.
         option domain-name-servers 10.10.0.1; # IP-адрес DNS-сервера, который будет использовать ws11. Здесь используется тот же DNS-сервер, что и для всей подсети.
         }
}
```

- Выполнила команду от имени администратора `sudo` `systemctl restart isc-dhcp-server`, чтобы перезапустить систему **DHCP-сервера** на **r1**.
- Выполнила команду от имени администратора `sudo` `systemctl status isc-dhcp-server`, чтобы проверить статус работы системы на **r1**.

> Успешно запущенная система **DHCP-сервера** (r1):
>
> ![alt text](Screen/49.20.png)
>

- Перезапустила систему **netplan** командой от имени администратора `sudo` `natplan apply` на **ws11**, чтобы обновить ip адрес интерфейса.
- Выполнила команду `ip a`, чтобы проверить успешное получение нового ip.

> Новый ip полученный по MAC-адресу (ws11):
>
> ![alt text](Screen/49.21.png)
>

- Пропинговала **ws22** с **ws11**, командой `ping -c 3 10.20.0.36`, указав отправку 3 пакетов.

> Успешно пропингованный ip 10.20.0.36:
>
> ![alt text](Screen/49.22.png)
>

- Проверила ip адрес интерфейса у машины **ws21** командой `ip a`.

> ip адрес интерфейса `enp0s8` (ws21):
>
> ![!\[ip адрес интерфейса enp0s8 ws21\](screen%2Fscreen_6_24.png)](Screen/49.24.png)
>
> Статический ip 10.20.0.10/26, который мы указали в файле конфигураций **netplan**.
>

- Выполнила команду от имени администратора `sudo` `dhclient -r` на **ws21**.
- Выполнила команду от имени администратора `sudo` `dhclient` на **ws21**.

*Команда `dhclient` используется для управления DHCP-клиентом на Linux-системах.*

<details><summary>Разбор команд:</summary>

-
  - Команда `sudo dhclient` с флагом `-r`: Эта команда освобождает (отменяет) текущий IP-адрес, полученный через **DHCP**. Флаг `-r` говорит DHCP-клиенту "отказаться" от IP-адреса, который был выдан ему DHCP-сервером. При этом DHCP-клиент отправляет на сервер сообщение о том, что он больше не использует данный IP-адрес.
  - Команда `sudo dhclient`: Когда вы запускаете команду **dhclient**, система отправляет запрос **DHCP Discover** для поиска DHCP-сервера в сети. Затем сервер выдает IP-адрес и другие сетевые параметры (например, шлюз и DNS-серверы), которые система применяет.

</details>


- Проверила получение нового ip от нашего **DHCP-сервера**, командой `ip a`.

> Новый ip адрес (ws21):
>
> ![alt text](Screen/49.26.png)
>
> `10.20.0.37/26` - полученный ip от нашего **DHCP-сервера**, из диапазона (range): `10.20.0.36` - `10.20.0.50`.
>

- Сохранила дампы образов виртуальных машин в настройках **Virtual Box**.

> Сохранение дампов образов виртуальных машин в VB:
> ![alt text](Screen/49.31.png)
>

----------------------------------------------------------------------------

## 7. NAT:

- Установила утилиту `apache2` на машины **ws22** **r1**, командой от имени администратора `sudo` `apt install apache2`.

- В файле `/etc/apache2/ports.conf` на **ws22** и **r1** изменила строку `Listen 80` на `Listen 0.0.0.0:80`, то есть сделал сервер Apache2 общедоступным.


> Файл `/etc/apache2/ports.conf` после изменений (ws22):
>
> ![alt text](Screen/50.1.png)
>

> Файл `/etc/apache2/ports.conf` после изменений (r1):
>
> ![alt text](Screen/50.2.png)
>

- Запустила веб-сервер Apache командой от имени администратора `sudo` `service apache2 start` на **ws22**.
- Проверила статус сервера командой от имени администратора `sudo` `service apache2 status` на **ws22**.


> Успешный запуск сервера `Apache` (ws22):
>
> ![alt text](Screen/50.3.png)
>

- Запустила веб-сервер Apache командой от имени администратора `sudo` `service apache2 start` на **r1**.
- Проверила статус сервера командой от имени администратора `sudo` `service apache2 status` на **r1**.


> Успешный запуск сервера `Apache` (r1):
>
> ![alt text](Screen/50.4.png)
>

- Добавила в фаервол, созданный по аналогии с фаерволом из [Части 4](#4-сетевой-экран), на **r2** следующие правила:

> Созданый срипт-файл `/etc/firewall.sh` на **r2**:
>
> ![alt text](Screen/50.6.png)
>

```bash
#!/bin/sh

# очистка всех правил в таблице «filter» (по умолчанию).
iptables -F  # очистка всех правил в таблице "filter".
iptables -X  # удаление всех нестандартных цепочек в таблице "filter".

# очистка всех правил в таблице «nat» (таблица для Network Address Translation).
iptables -F -t nat  # очистка всех правил в таблице "nat".

# установка политики по умолчанию для цепочки FORWARD (маршрутизация) — сброс всех пакетов.
iptables --policy FORWARD DROP  # устанавливает политику по умолчанию для цепочки "FORWARD", которая будет отбрасывать все маршрутизируемые пакеты.
```

- Разрешила доступ и запустила файл на **r2** командами от имени администратора `sudo` `chmod +x /etc/firewall.sh` и `sudo` `/etc/firewall.sh`.

> Применение команд `sudo` `chmod +x /etc/firewall.sh` и `/etc/firewall.sh` (r2):
>
> ![alt text](Screen/50.5.png)
>

- Выполнила команду от имени администратора `sudo` `iptables -L --line-number`, чтобы проверить список действующих правил фаервола.

- Попыталась пропинговать **ws22** c **r1**, с указанием 4 пакетов, командой `ping -с 4 10.20.0.38`.

> Пинг `ip 10.20.0.38` ws22 без ответа (r1):
>
> ![!\[Пинг ws22 без ответа ip 10.20.0.20 r1\](screen%2Fscreen_7_10.png)](Screen/50.7.png)
>

- Добавила новые правила в файл `/etc/firewall.sh` на **r2**, чтобы разрешить маршрутизацию всех пакетов протокола ICMP.

> Измененный файл `/etc/firewall.sh` (r2):
>
> ![alt text](Screen/50.8.png)
>

```bash
#!/bin/sh

# очистка всех правил в таблице «filter» (по умолчанию).
iptables -F  # очистка всех правил в таблице "filter".
iptables -X  # удаление всех нестандартных цепочек в таблице "filter".

# очистка всех правил в таблице «nat» (таблица для Network Address Translation).
iptables -F -t nat  # очистка всех правил в таблице "nat".

# установка политики по умолчанию для цепочки FORWARD (маршрутизация) — сброс всех пакетов.
iptables --policy FORWARD DROP  # устанавливает политику по умолчанию для цепочки "FORWARD", которая будет отбрасывать все маршрутизируемые пакеты.

# разрешение прохождения всех ICMP-пакетов (например, ping) через маршрутизатор.
iptables -A FORWARD -p icmp -j ACCEPT  # добавляет правило, позволяющее ICMP-пакетам проходить через маршрутизатор.
```

- Разрешила доступ и запустила файл на **r2** командами от имени администратора `sudo` `chmod +x /etc/firewall.sh` и `sudo` `/etc/firewall.sh`.

> Применение команд `sudo` `chmod +x /etc/firewall.sh` и `/etc/firewall.sh` (r2):
>
> ![!\[Применение команд sudo chmod +x /etc/firewall.sh и /etc/firewall.sh r2\](screen%2Fscreen_7_12.png)](Screen/50.9.png)
>

- Пропинговала **ws22** c **r1**, с указанием 2 пакетов, командой `ping -с 2 10.20.0.38`.

> Успешно пропингованный `ip 10.20.0.38` (r1):
>
> ![alt text](Screen/50.10.png)
>

- Добавила новые правила в файл `/etc/firewall.sh` на **r2**:
  - Включила **SNAT**, а именно маскирование всех локальных ip из локальной сети, находящейся за **r2**.
  - Включила **DNAT** на **8080** порт машины **r2**.
  - Добавила к веб-серверу **Apache**, запущенному на **ws22**, доступ извне сети.
  - Разрешила tcp-соединение, предназначенное **ws22** и **80 порту**.

> Измененный файл `/etc/firewall.sh` (r2):
>
> ![alt text](Screen/50.17.png)
>

```bash
#!/bin/sh

# очистка всех правил в таблице «filter» (по умолчанию).
iptables -F  # очистка всех правил в таблице "filter".
iptables -X  # удаление всех нестандартных цепочек в таблице "filter".

# очистка всех правил в таблице «nat» (таблица для Network Address Translation).
iptables -F -t nat  # очистка всех правил в таблице "nat".

# установка политики по умолчанию для цепочки FORWARD (маршрутизация) — сброс всех пакетов.
iptables --policy FORWARD DROP  # устанавливает политику по умолчанию для цепочки "FORWARD", которая будет отбрасывать все маршрутизируемые пакеты.

# разрешение прохождения всех ICMP-пакетов (например, ping) через маршрутизатор.
iptables -A FORWARD -p icmp -j ACCEPT  # добавляет правило, позволяющее ICMP-пакетам проходить через маршрутизатор.

# разрешение прохождения всех TCP-пакетов через маршрутизатор.
iptables -A FORWARD -p tcp -j ACCEPT  # добавляет правило, позволяющее TCP-пакетам проходить через маршрутизатор.

# настройка SNAT для маскировки исходящих пакетов, заменяя их исходный IP на 10.100.0.12.
iptables -t nat -A POSTROUTING -o enp0s8 -s 10.20.0.0/16 -j SNAT --to-source 10.100.0.12

# настройка DNAT для перенаправления входящих пакетов на порт 8080 к внутреннему серверу на 10.20.0.20:80.
iptables -t nat -A PREROUTING -p tcp -d 10.20.0.1 --dport 8080 -j DNAT --to-destination 10.20.0.20:80
```

- Отключила сетевой интерфейс NAT на **r2** в **VirtualBox**.

> Отключение сетевого интерфейса enp0s3 в **VBx** (r2):
>![alt text](Screen/50.12.png)
>

- Отключила настройки `dhcp` интерфейса `enp0s3` в файле `/etc/netplan/00-installer-config.yam` на **r2**.
- Применила настройки `netplan`, командой от имени администратора `sudo` `netplan apply` на **r2**.
- Проверила отключение интерфейса `enp0s3`, командой `ip a` на **r2**.

> Список активных сетевых интерфейсов (r2):
>
> ![alt text](Screen/50.15.png)
>

- Разрешила доступ и запустила файл фаервола на **r2** командами от имени администратора `sudo` `chmod +x /etc/firewall.sh` и `sudo` `/etc/firewall.sh`.

> Применение команд `sudo` `chmod +x /etc/firewall.sh` и `/etc/firewall.sh` (r2):
>
> ![alt text](Screen/50.13.png)
>

- Выполнила команду от имени администратора `sudo` `iptables -L --line-number`, чтобы проверить список действующих правил фаервола.

> Вывод команды `sudo` `iptables -L --line-number` (r2):
>
> ![alt text](Screen/50.14.png)
>

- Проверила соединение по **TCP** для **SNAT**: для этого с **ws22** подключиться к серверу **Apache** на **r1** командой `telnet 10.10.0.1 80`.

> Вывод команды `telnet 10.10.0.1 80` (ws22):
>
> ![alt text](Screen/50.16.png)
>

- Проверила соединение по **TCP** для **DNAT**: для этого с **r1** подключиться к серверу **Apache** на **ws22** командой `telnet 10.20.0.1 8080`, обращался по адресу **r2** и порту **8080**.

> Вывод команды `telnet 10.20.0.1 8080` (r1):
>
> ![alt text](Screen/50.18.png)
>

- Сохранила дампы образов виртуальных машин в настройках **Virtual Box**.

> Сохранение дампов образов виртуальных машин в VB:
>
> ![alt text](Screen/50.23.png)
>

----------------------------------------------------------------------------

## 8. Знакомство с SSH Tunnels:
- Открыла дампы виртуальных машин на состояние завершенного [Части 5](#5-статическая-маршрутизация-сети).
- Виртуальную машину **r2** открыв на состояние завершенного [Части 7](#7-nat).

- Установила утилиту `apache2` на **ws22**.
- В файле `/etc/apache2/ports.conf` на **ws22** изменила строку `Listen 80` на `Listen localhost:80`.

*Это нужно чтобы `Apache` слушал только на localhost (127.0.0.1).*

> Измененный файл `/etc/apache2/ports.conf` (ws22):
>
> ![alt text](Screen/51.1.png)
>

- Перезапустила сервис `apache2`, командой от имени администратора `sudo` `service apache2 restart`.
- Проверила работу сервиса, командой от имени администратора `sudo` `service apache2 status`.

> Успешный запуск `apache2` (ws22):
>
> ![!\[Успешный запуск apache2 ws22\](screen%2Fscreen_8_03.png)](Screen/51.2.png)
>

- Установила сервис `ssh` на **ws22**
- Проверила статус сервиса `ssh`, командой от имени администратора `sudo` `service ssh status`.

> Успешный запуск `ssh` (ws22):
>
> ![!\[Успешный запуск ssh ws22\](screen%2Fscreen_8_04.png)](Screen/51.3.png)
>

**Настройка Local TCP Forwarding с ws21 до ws22:**

*Local TCP Forwarding позволяет перенаправить локальный порт на ws21 к порту на ws22 через SSH-туннель.*

- Выполнила команду на **ws21** `ssh -L 8080:localhost:80 user@10.20.0.20`.

*`8080` — это порт на ws21, через который мы будем получать доступ к Apache на ws22.*

> Успешное подключение по ssh с ws21 к ws22:
>
> ![alt text](Screen/51.4.png)
>

- Переключилась на второе окно терминала сочетанием клавиш `alt` + `F3`.
- Для проверки подключения, в терминале **ws21** ввела команду `telnet 127.0.0.1 8080`.

> Вывод команды `telnet 127.0.0.1 8080` (ws21):
>
> ![alt text](Screen/51.7.png)
>

- Выполнила команду на **ws11** `ssh -R 9090:localhost:80 user@10.20.0.20`.

*`9090` — это порт на ws11, через который мы будем получать доступ к Apache на ws22.*

> Успешное подключение по ssh с ws11 к ws22:
>
> ![alt text](Screen/51.6.png)
>

- Переключилась на второе окно терминала сочетанием клавиш `alt` + `F3`.
- Для проверки подключения, в терминале **ws11** ввела команду `telnet 127.0.0.1 9090`.

> Вывод команды `telnet 127.0.0.1 9090` (ws11):
>
> ![alt text](Screen/51.9.png)
>

- Разбор команд:
  - `ssh -L [local_port]:[remote_host]:[remote_port] [user]@[ssh_server]`:
    - Флаг `-L`: используется для создания локального перенаправления (**Local TCP forwarding**). 
    - `[local_port]` — локальный порт на нашей машине (**ws21**), который будет прослушиваться.
    - `[remote_host]` — целевой удаленный хост (например, **localhost** на **ws22**), к которому должен подключаться туннель.
    - `[remote_port]` — порт удаленного хоста, к которому туннель будет подключаться.
    - `[ssh_server]` — **SSH-сервер (ws22)**, через который будет установлен туннель.


***Local forwarding** (`-L`) позволяет вам перенаправить порт на вашей локальной машине (**ws21**) через **SSH-соединение**, чтобы достучаться до удаленного порта на другой машине (**ws22**).*

*Мы подключились по **SSH** к **ws22**, и любой запрос к localhost:8080 на нашей локальной машине (ws21) будет отправляться на порт 80 на **localhos**t на **ws22**.  Команда `telnet 127.0.0.1 8080` на **ws2**1 работает, потому что `localhost:8080` на **ws21** перенаправляется на `localhost:80` на **ws22**.*

-
  - `ssh -R [remote_port]:[local_host]:[local_port] [user]@[ssh_server]`:
    - Флаг `-R`: используется для создания удаленного перенаправления (**Remote TCP forwarding**).
    - `[remote_port]` — порт на удаленном **SSH-сервере** (**ws22**), который будет прослушиваться.
    - `[local_host]` — локальный хост (например, **localhost** на **ws11**), к которому должен подключаться туннель.
    - `[local_port]` — порт на локальном хосте, к которому туннель будет подключаться.
    - `[ssh_server]` — **SSH-сервер**, через который устанавливается туннель (**ws22**).

***Remote forwarding** (`-R`) позволяет перенаправить порт на удаленной машине (**ws22**) на локальный порт на вашей машине (**ws11**).*

*Это создаст **SSH-туннель**, который заставит **ws22** прослушивать порт `8080`. Любой трафик, идущий на `ws22:8080`, будет перенаправлен на `localhost:80` на вашей локальной машине (**ws11**).*

***Local forwarding** (`-L`) на `ws11` будет правильным подходом, если мы хотим подключиться к веб-серверу на `ws22`, используя локальный порт на `ws21`. Если с флагом `-L` все работает, это означает, что туннель настроен правильно для этой цели.*

***Remote forwarding** (`-R`) при подключении к `ws22`, нужно использовать, если мы хотим перенаправить порт с `ws11` (или другого клиента) на `ws22`, но в нашем сценарии мы используем его наоборот, что неправильно.*

*В нашем случае, использование `-L` на `ws21` для туннелирования доступа к веб-серверу на `ws22` — правильный подход.*

*Если мы подключаемся с использованием `-R` и у нас возникает ошибка `connection refused` при попытке использовать `telnet`, это потому, что `-R` перенаправляет порт на удаленной машине (`ws22`), а не на локальной (`ws11`). Следовательно, в нашем сценарии `-R` не дает нужного результата.*

**Заключение: нужно использовать флаг `-L` для локального перенаправления с `ws11`, чтобы получить доступ к веб-серверу на `ws22`, и именно поэтому `telnet` работает с использованием `-L`.**

- Сохранила дампы образов виртуальных машин в настройках **Virtual Box**, по аналогии с [заданием 4](#4-сетевой-экран), [заданием 5](#5), [заданием 6](#6-динамическая-настройка-ip-с-помощью-dhcp) и [заданием 7](#7-nat).

> Сохранение дампов образов виртуальных машин в VB:
> ![alt text](Screen/51.10.png)
> 

----------------------------------------------------------------------------
